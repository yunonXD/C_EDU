----------------------------------------------------------------------
기수정렬
----------------------------------------------------------------------

- 정렬순서의 앞서고 뒤섬을 비교하지 않음

- 정렬 알고리즘의 한계로 알려진 O(nlog2n) 을 뛰어넘을 수 있음

- 적용할 수 있는 대상이 매우 제한적임 ("길이가 동일"한 데이터들의 정렬에 용이함)
    -> 1 ,7 ,9 ,5 ,2 6 을 오름차순으로 정렬 (가능)
    -> red ,why ,zoo ,box 를 사전편찬 순서로 정렬 (가능)
    -> 21 ,-9 ,125 ,8 ,-136 ,45 를 오름차순으로 정렬 (불가능)
    -> professionalism ,few ,hydroxyproline ,simple 을 사전 편찬 순서대로 정렬 (불가능)



----------------------------------------------------------------------
기수정렬 - 원리
----------------------------------------------------------------------

정렬 알고리즘이지만 "비교"를 진행하지 않는 특이점이 있다.

기수(radix) :주어진 데이터를 구성하는 기본 요소 (기호)
버킷(bucket) :기수의 수에 해당하는 만큼 버킷을 활용


|6 5 2 8|
|ㅁㅁㅁㅁ|

ㅁ 버킷0
ㅁ 버킷1
ㅁ 버킷2 >2
ㅁ 버킷3
ㅁ 버킷4
ㅁ 버킷5 >5
ㅁ 버킷6 >6
ㅁ 버킷7
ㅁ 버킷8 >8
ㅁ 버킷9

순서대로 out >> |2 5 6 8| (오름차순) 내림차순은 반대로 꺼내기

하지만 정말 비교연산을 하지 않았을까?
약간의 비교연산을 추가할 수 도 있다. (배열이 아니라면?)
하지만 "상징적으로" 비교 연산이 불필요하다고 말 한다.




----------------------------------------------------------------------
기수정렬 - LSD
----------------------------------------------------------------------
LSD :List Significant Digit 값의 중요도가 낮은 숫자


(1) 우선순위가 낮은 순위부터 정렬 진행

        (기준)      (입구>)버킷0(출구>)              (끝자리수 정렬)          
  1   3   4               버킷1                       2   3   2
  2   2   4               버킷2 (1 2 2 / 2 2 2)       1   2   2
  2   3   2               버킷3                       1   3   4
  1   2   2               버킷4 (2 2 4 / 1 3 4)       2   2   4


(2) 우선순위가 두번째로 낮은 순위부터 정렬 진행

    (기준)          (입구>)버킷0(출구>)              (끝자리수 정렬)          
  2   3   2               버킷1                       1   2   2
  1   2   2               버킷2 (2 2 4 / 1 2 2)       2   2   4
  1   3   4               버킷3 (1 3 4 / 2 3 2)       2   3   2
  2   2   4               버킷4                       1   3   4


(3) 마지막 정렬 진행

(기준)              (입구>)버킷0(출구>)              (끝자리수 정렬)          
  1   2   2               버킷1 (1 3 4 /1 2 2)        1   2   2
  2   2   4               버킷2 (2 3 2 /2 2 4)        1   3   4
  2   3   2               버킷3                       2   2   4
  1   3   4               버킷4                       2   3   2

(4) 최종 정렬 결과

(끝자리수 정렬)          
  1   2   2
  1   3   4
  2   2   4
  2   3   2


버킷은 정렬할 기수가 아무리 많아도 10개면 충분하다. (0~9)


----------------------------------------------------------------------
기수정렬 - LSD -구현
----------------------------------------------------------------------

일단 구현의 심플함을 위해 3자리 수로 진행.

NUM 으로부터 첫 번째 자리 숫자 추출 >> NUM / 1 % 10
NUM 으로부터 두 번째 자리 숫자 추출 >> NUM / 10 % 10
NUM 으로부터 세 번째 자리 숫자 추출 >> NUM / 100 % 10
...

이러한 형태로 각 자릿수의 파트를 추출


----------------------------------------------------------------------
기수정렬 - MSD
----------------------------------------------------------------------
MSD :Most Significant Digit 값의 중요도가 높은 숫자

MSD 방식은 점진적으로 정렬이 완성되어 가는 방법.
따라서 중간 중렬에 정렬이 완료된 데이터는 더 이상의 정렬 과정을 진행하지 않아야 함


MSD 의 문제점? 아래의 그림을 참고.

(기준)          (기준)           (기준)     (결과:??)
  1 3 4         1 3 4         1 2 2         1 2 2
  2 2 4         1 2 2         2 2 4     >>  2 3 2
  2 3 2         2 2 4         1 3 4     >>  2 2 4
  1 2 2         2 3 2         2 3 2         1 3 4


MSD 의 문제를 해결?

(기준)          (기준)           (기준)     (결과:??)
  1 3 4         1 3 4         1 2 2         1 2 2
  2 2 4         1 2 2         2 2 4     >>  2 3 2
  2 3 2         2 2 4         1 3 4     >>  2 2 4
  1 2 2         2 3 2         2 3 2         1 3 4
               (ㄴ여기서 앞의 1 과 2를 나눠야함)

MSD 는 결과를 대략 앞에서 알 수 있음 (LSD 는 마지막에 결과가 나와야 알 수 있음)
단 성능은 보이는것과 같이 더 앞서거나 그런건 아님

