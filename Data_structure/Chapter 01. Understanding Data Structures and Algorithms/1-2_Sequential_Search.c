#include<stdio.h>

//순차 탐색 알고리즘 적용
int LSearch(int ar[], int len, int target){
    for(int i = 0; i < len; i++){
        if(ar[i] == target)
            return i;               //찾은 대상의 인덱스 값 return
    }
    return -1;                      //찾지 못했음을 return
}


int main(int argc, char *argv[]){



    return 0;
}


/*

중심이 되는 연산자 찾기
최악의 경우와 최상의 경우?
> 순차 탐색 상황 1: 운이 정말 "좋은" 경우
     - 배열의 맨 앞에서 대상을 찾는 경우
     - 만족스러운 상황이므로 성능평가 대상은 아님
     - 최상의 경우(Best case) 라고 함
     - 배열<ㅁㅁㅁㅁㅁ...> 길이 n 일때 맨 앞에 있으면 T(n) = 1 <<한번만 싸이클을 돌았음

> 순차 탐색 상황 2: 운이 정말 "나쁜" 경우
     - 배열의 끝에서 찾거나 대상이 없는 경우
     - 만족스럽지 못한 상황이므로 성능평가 대상
     - 최악의 경우 (worst case) 라고 함
     - 배열<ㅁㅁㅁㅁㅁ...> 길이 n 일때 맨 뒤에 있으면 T(n) = n << 길이만큼 싸이클을 돌았음
     - 데이터 수가 n 개 일때 최악의 경우에 해당하는 연산 횟수(비교연산)는 n 이다
        T(n) = n 최악의 경우를 대상으로 정의한 함수 T(n)


"평균"적인 경우 (Average Case)
가장 현실적인 경우에 해당
> 일반적으로 등장하는 상황에 대한 경우의 수
> 최상의 경우와 달리 알고리즘 평가에 도움이 된다
> 계산하기 까다롭다. 객관적인 평가도 어렵다.

평균적인 경우의 복잡도 계산이 어려운 이유
 > 평균적인 경우의 연출이 어렵다
 > 평균적인 경우임을 증명하기 어렵다
 > 평균적인 경우는 상황에 따라 달라진다      But 최악의 상황은 동일함

 */