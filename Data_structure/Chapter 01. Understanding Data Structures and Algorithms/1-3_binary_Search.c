#include<stdio.h>

//이진탐색 알고리즘

int BSearch(int arr[],int len, int target){


//          first ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ mid ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ last

    int first = 0;
    int last = len -1;
    int mid = 0;

    while(first <= last){
        mid = (first + last)/2;             //탐색 대상의 중앙 search
        if(target == arr[mid])              //비교 연산자 = 핵심 연산자 (시간복잡도확인)
            return mid;
        else{                               //본격적으로 반가르기 시작
            if(target<arr[mid])
                last = mid -1;
            else
                first = mid +1;
        }
    }
    return -1;      //target 못찾음
}

int main(int argc, char *argv[]){

    return 0;
}




/*

이진탐색 알고리즘
----------------
순차탐색보다 훨씬 좋은 성능을 보이지만 배열이 "정렬"되어 있어야 가능하다는 점에서 제약이 따른다
허나 이러한 제약때문에 순차탐색보다 좋은 성능인것.


1       2       3       7      9     12     21     23     27
arr[0] arr[1] arr[2] arr[3] arr[4] arr[5] arr[6] arr[7] arr[8]   3의 저장 위치를 찾는다면?


-------------------------------------------------------------------
1       2       3       7      =9=     12     21     23     27
arr[0] arr[1] arr[2] arr[3] =arr[4]= arr[5] arr[6] arr[7] arr[8]
-------------------------------------------------------------------
    > 이진 탐색 알고리즘의 첫 번째 시도
        - 배열 인덱스의 시작과 끝은 각각 0과 8
        - 0과 8을 합해 2로 나누기       (가운데 값 얻기)
        - 2로 나워서 얻은 결과 4를 인덱스값으로 하여 arr[4]에 저장된 값이 3인지 확인

-------------------------------------------------------------------
1       ==2==       3       7
arr[0] ==arr[1]== arr[2] arr[3]
-------------------------------------------------------------------
    > 이진 탐색 알고리즘의 두 번째 시도
        - arr[4] 에 저장된 값 9와 탐색 대상 3의 대소 비교를 실시
        - 대소 비교 결과 arr[4] > 3 이므로 탐색 범위를 인덱스 기준 0~3으로 제한
        - 0과 3 을 더해 결과를 또 2로 나눔 나머지를 버림
        - 2 로 나눠서 얻은 결과가 1이니 arr[1] 에 저장된 값이 3인지 확인

 -------------------------------------------------------------------
==3==       7
==arr[2]== arr[3]
-------------------------------------------------------------------
    
    > 이진 탐색 알고리즘의 세 번째 시도
        - arr[1]에 저장된 값 2와 탐색 대상인 3의 대소를 비교
        - 대소 비교 결과 arr[1] <  3 이므로 탐색 범위를 인덱스 기준 2~3 으로 제한
        - 2 와 3을 더해 2로 나누기 나머지는 버림
        - 2로 나눠서 얻은 결과 : 2 arr[2] 에 저장된 값이 3 인지 확인




이잔탐색 알고리즘의 최악의 경우 시간 복잡도1
-----------
    시간 복잡도를 계산하기 위한 핵심 연산이라고 하면? >> "==" 연산자
    즉 == 연산자의 연산 횟수를 파악하면 대략적인 시간 복잡도를 결정 가능

    데이터 수가 n 개 일때 비교 연산의 횟수? 언제까지는 표현할 수 있지만 "몇변?" 인지는 표현 불가능?

    > 비교 연산 횟수의 예
        - 8이 1이 될때까지 2로 나눈 횟수 3회, 따라서 비교연산은 3번
        - 데이터가 1개 남았을 때, 이때 마지막으로 비교연산 1회 진행

    > 비교 연산 횟수의 일반화
        - n 이 1 될때까지 2로 나눈 횟수 k 회, 따라서 비교연산 k 번
        - 데이터가 1개 남았을 때, 마지막 비교연산 1회 진행

    > 비교 연산 횟수 결론
        - 최악의 case 시간 복잡도 T(n) = k+1 
        - log2 n + 1
        - 즉 시간 복잡도는 log2n
    




*/