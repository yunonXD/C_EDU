-------------------------------------
그래프의 이해
-------------------------------------

쾨니히스베르크의 다리 문제
모든 다리를 한 번씩만 건너서 처음 출발한 장소로 돌아올 수 있는가?

정점과 간선으로 표현해서 불가능함을 증명함

그래프는 표현 방법이며 그래표로 표현한 별도의 알고리즘을 학습

-------------------------------------
그래프의 종류
-------------------------------------
 -무방향 그래프 /무방향 완전 그래프
 -방향 그래프   /방향 완전 그래프
 -무방향 가중치 그래프
 -방향 가중치 그래프
 -부분 가중치 그래프

 
-------------------------------------
그래프의 집합 표현
-------------------------------------

V <<정점의 표현
G <<간선의 표현

V(G1) = {A ,B ,C D}
E(G1) = {(A,B) ,(A,C) ,(A,D) ,(B ,C) ,(C,D)}

V(G2) = {A ,B ,C D}
E(G2) = {(A,C) ,(A,D) ,(B ,C)}


V(G3) = {A ,B ,C D}
E(G3) = {<A,B> ,<A,C> ,<D,A>}


V(G4) = {A ,B ,C D}
E(G4) = {<A,C> ,<B,C> ,<D,A>}



-------------------------------------
그래프의 ADT
-------------------------------------

void GraphInit(UALGraph *pg ,int nv);
    - 그래프의 초기화를 진행
    - 두 번째 인자로 정점의 수를 전달

void GraphDestroy(UALGraph *pg);
    - 그래프 초기화 과정에서 할당한 리소스를 리턴

void AddEdge(UALGraph *pg ,int fromV ,int ToV);
    - 매개변수 fromV 와 ToV 로 전달된 정점을 연결하는 간선 그래프 추가

void ShowGraphEdgeInfo(UALGraph *pg );
    - 그래프 간선 정보 출력


구현 방법? : 인접 배열 혹은 인접 리스트




-------------------------------------
그래프의 탐색
-------------------------------------

모든 정점을 돌아다니는 방법을 구현하는것이 문제.
그래프는 모양(구조)가 항상 다르다는것이 다른 탐색과 다르다.

깊이 우선 탐색
너비 우선 탐색


-------------------------------------
그래프의 탐색 - Depth First Search 깊이 우선 탐색
-------------------------------------

한바퀴 돌아서 자신에게 돌아온다 (모든 노드를 탐색함)

다음 next 가 없으면 되돌아 오는게 포인트

처음 지점으로 돌아오면 끝


-------------------------------------
그래프의 탐색 - Breadth First Search 너비 우선 탐색
-------------------------------------

연결된 모든 노드에게 전달 
하나의 노드는 한번만 전달을 받는 형태
마지막에 노드 하나가 남는다 (처음 노드로 돌아오지 않는다)



-------------------------------------
최소 비용 신장트리
-------------------------------------

=="싸이클"==
    > 쉽게 말해서 바보같이 가지 않는것.
    > A 에서 B 까지 가는데 바로 가는 경로를 탐색 (한번 들린 정점을 다시 들리지 않는) 하는걸 "단순경로" 라고 함
    > 근데 이게 무조건 최단거리만 구하는건 아님 의무적으로(조건에의해) 어떤 노드를 경유해야만 할 수 도 있기때문
    > 이러한 시작점과 끝점이 같은 단순한 경로를 가리켜 "사이클" 이라고 함


어떠한 경로를 만들어도 사이클 구성에 실패하는 그래프 : "신장 트리" >> 사이클 형성이 안된다면 트리의 모습이 나타남
즉.. 사이클 형성을 안함 = 트리의 일종
신장 그래프가 아닌 신장트리라 부르는 이유가 이것.


=신장 트리의 특징
 - 그래프의 모든 정점이 간선에 의해 하나로 연결되어 있음
 - 그래프 내에서 사이클 형성은 없음

거리를 이동하는데 소비하는 비용이 "최소" 로 들어가는것이 포인트

최소비용 신장트리 조건 => 간선 수 + 1 = 정점의 수

크루스칼 알고리즘 
    1. 간선 추가 방법
    2. 간선 삭제 방법